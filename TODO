# vim: set filetype=org :

* legion TODO

** components
   - thin client, written in bash with ssh and git
   - real client, written in clojurescript to run on node, mostly an http client
   - server, clojure server

** builder
   - docker
   - specify images as a tree
   - add .dockerignore
   - will build take a from param?
   - qualified name in FROM - namespace/name? force tagged version?
   - build in sandbox? (how else to allow multiple versions with same name?) this might prevent using cache
   - how to maintain cache?
   - how to maintain logs?
   - allow only one build per project

** runner
   - service routing
   - docker (add concept of application)
   - marathon

** router
   - haproxy

** misc
   - middleware, what should it do?
   - versioning?
   - rollback?
   - zero downtime?
   - high availability?
   - how do I get insight into its succes or failure?
   - when is it triggered?
   - it's a pipeline, operating on the value of the running application


** reformat the following comments...

# ;; /api/v1/app/bunsen/images/
#
#      ;; /api/v1/at/08-10-2014/
#      ;; /api/v1/at/SHA/images/
#
#      ;; /api/v1/at/HEAD/images/web/build
#      ;; /api
#
#      ;; all of these actions are analogous to git commands
#
#      ;; legion --target=shared build web
#      ;; legion build web --> POST /api/v1/ref/SHA/images/web/build
#      ;; legion restart web --> POST /api/v1/ref/SHA/services/web/shift type=stop,start - becomes the current HEAD
#      ;;                    |-> PUT /api/v1/ref/HEAD ref=SHA
#      ;; legion wire web ->
#
#      ;; push
#
#      ;; /api/v1/routes
#      ;; /api/v1/images
#      ;; /api/v1/services
#
#      ;;
#      ;; builder flow
#      ;;
#      ;;   push git repo (or run legion build)
#      ;;   post-receive hook executes legion build on server, passing commit SHA (does this block?)
#      ;;     or maybe posts with the path to the repo? like a github hook...
#      ;;   legion server evaluates middleware chain, starting with build step
#      ;;   checkout commit into temp directory
#      ;;   parse build config, determine dependencies
#      ;;   rewrite dockerfiles FROM field, including project and commit sha
#      ;;   use docker to actually build containers (breadth first, pre order)
#      ;;     what gets logged?
#      ;;     probably should log to a well known structure, so the commiter can attach if necessary... let's call it a "file"
#      ;;
#      ;;   use git repo as primary storage
#      ;;   use flat log files to keep record of builds
#      ;;
#      ;;   necessary endpoints:
#      ;;     /api/v1/app/NAME/ref/SHA/images/NAME/build
#      ;;     /api/v1/app/NAME/ref/SHA/images/NAME/build/ID
#      ;;     /api/v1/app/NAME/ref/SHA/images/NAME/build/ID/log
#      ;;
#      ;;     /api/v1/app/NAME/ref/HEAD/build
#      ;;     /api/v1/app/bunsen/ref/HEAD/build (POST)
#      ;;
#
#      ;; tag every image we build so that it can be garbage collected
#
#      ;; /command
#      ;; /execute/build
#      ;; /execute {:command :build, :options}
#      ;; /execute?command=build
#      ;; /execute/ID/log
#
#      ;;
#      ;; mojotech/legion
#      ;; mojotech/legion-build
#      ;; mojotech/legion-deploy
#      ;; mojotech/legion-test
#      ;;
#      ;; legion.middleware.build
#
#      ;; /etc/legion/apps/bunsen.clj
#
#      ;; /app/bunsen/command
#      ;; /app/bunsen/ref/HEAD/execute
#
